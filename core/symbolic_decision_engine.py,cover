  # core/symbolic_decision_engine.py
  # -*- coding: utf-8 -*-
> """
> M√≥dulo oficial de decisiones simb√≥licas para EvoAnimusAI.
> Clasificaci√≥n: Nivel Dios / Militar / Gubernamental / Ultra-secreto.
  
> Responsabilidad:
> Toma de decisiones simb√≥licas estrat√©gicas a partir del contexto expandido, reglas simb√≥licas,
> state del agente, y par√°metros adaptativos. Incluye control de entropy, priorizaci√≥n heur√≠stica
> y trazabilidad para auditor√≠a de seguridad.
  
> Integraci√≥n:
> - symbolic_entropy_controller
> - symbolic_rule_engine
> - rule_manager
> """
  
! import logging
! from typing import Dict, Any, Optional, List
  
! from core.context import EvoContext
! from symbolic_ai.symbolic_entropy_controller import check_entropy, should_halt
! from symbolic_ai.rule_manager import version_rule, diff_rules
! from symbolic_ai.symbolic_rule_engine import SymbolicRuleEngine, SymbolicRule
  
! logger = logging.getLogger("EvoAI.SymbolicDecisionEngine")
  
  
! class ToolManager:
!     """
!     Gestor de herramientas auxiliares del sistema de decisi√≥n simb√≥lica.
!     Permite inicializar m√≥dulos de asistencia, visualizaci√≥n o auditor√≠a simb√≥lica.
!     """
!     def initialize(self, verbose: bool = False) -> None:
!         if verbose:
!             logger.info("[üõ†Ô∏è] Inicializando herramientas auxiliares...")
          # Aqu√≠ se pueden cargar o preparar m√≥dulos adicionales, visualizadores, analizadores, etc.
          # Ejemplo futuro: self.visualizer = SymbolicGraphVisualizer()
!         pass
  
  
! class SymbolicDecisionEngine:
!     """
!     Motor de decisiones simb√≥licas adaptativas.
  
!     M√©todos:
!     - decide(context): Eval√∫a el contexto recibido, regula la entropy y devuelve la action priorizada.
!     - audit_decision(): Versiona y registra decisiones tomadas.
!     """
  
!     def __init__(self, context: EvoContext, engine: Optional[SymbolicRuleEngine] = None) -> None:
!         if not isinstance(context, EvoContext):
!             raise TypeError("El contexto debe ser una instancia de EvoContext.")
  
!         self.context = context
!         self.engine = engine or SymbolicRuleEngine()
!         self.last_decision = None
!         self.tools = ToolManager()
  
!         if not hasattr(self.engine, "evaluate") or not callable(getattr(self.engine, "evaluate")):
!             raise AttributeError("[INIT] El motor simb√≥lico proporcionado no implementa 'evaluate(context)'.")
  
!         logger.info("[‚úÖ SymbolicDecisionEngine] Inicializado con contexto, motor simb√≥lico y herramientas auxiliares.")
  
!     def decide(self, context: Dict[str, Any]) -> Dict[str, Any]:
!         """
!         Toma una decisi√≥n simb√≥lica a partir del contexto recibido.
  
!         Args:
!             context (Dict[str, Any]): Contexto simb√≥lico extendido para evaluaci√≥n.
  
!         Returns:
!             dict: Acci√≥n priorizada con metadatos.
!         """
!         logger.debug("[üß†] Iniciando evaluaci√≥n simb√≥lica con contexto externo...")
  
!         entropy = check_entropy(context)
!         if should_halt(entropy):
!             logger.warning(f"[‚ö†Ô∏è] Entrop√≠a cr√≠tica detectada ({entropy:.2f}). Emisi√≥n de action 'halt'.")
!             return {"action": "halt", "reason": "High symbolic entropy", "entropy": entropy}
  
!         try:
!             rules = self.engine.evaluate(context)
!             prioritized = self.prioritize_rules(rules)
  
!             if not prioritized:
!                 logger.warning("[‚ùó] No se pudo priorizar ninguna action. Emitiendo 'noop'.")
!                 return {"action": "noop", "reason": "No valid symbolic decision", "entropy": entropy}
  
!             selected = prioritized[0].to_dict()
!             selected["entropy"] = entropy
!             selected["source"] = "symbolic_decision_engine"
  
!             self.last_decision = selected
!             self.audit_decision(selected)
!             logger.info(f"[‚úÖ] Acci√≥n seleccionada: {selected}")
!             return selected
  
!         except Exception as e:
!             logger.error(f"[‚ùå] Fallo cr√≠tico en SymbolicDecisionEngine.decide: {e}", exc_info=True)
!             return {"action": "error", "reason": str(e), "source": "symbolic_decision_engine"}
  
!     def prioritize_rules(self, rules: List[SymbolicRule]) -> List[SymbolicRule]:
!         """
!         Priorizaci√≥n heur√≠stica de reglas simb√≥licas activadas.
  
!         Args:
!             rules (List[SymbolicRule]): Reglas activadas.
  
!         Returns:
!             List[SymbolicRule]: Lista ordenada por confianza (confidence).
!         """
!         logger.debug("[üìä] Priorizando reglas simb√≥licas...")
  
!         try:
!             prioritized = sorted(
!                 rules,
!                 key=lambda r: getattr(r, "confidence", 0.0),
!                 reverse=True
!             )
!             return prioritized
!         except Exception as e:
!             logger.error(f"[‚ùå] Error en priorizaci√≥n simb√≥lica: {e}", exc_info=True)
!             return []
  
!     def prioritize(self, rule_outputs: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
!         """
!         M√©todo p√∫blico para cumplir interfaz esperada por el sistema externo.
  
!         Args:
!             rule_outputs (List[Dict]): Resultados previos de evaluaci√≥n simb√≥lica.
  
!         Returns:
!             List[Dict]: Lista priorizada.
!         """
!         logger.debug("[üìä] Priorizando desde interfaz externa...")
!         try:
!             prioritized = sorted(
!                 rule_outputs,
!                 key=lambda x: x.get("confidence", 0.0),
!                 reverse=True
!             )
!             return prioritized
!         except Exception as e:
!             logger.error(f"[‚ùå] Error al priorizar desde interfaz externa: {e}", exc_info=True)
!             return []
  
!     def audit_decision(self, decision: Dict[str, Any]) -> None:
!         """
!         Versiona y registra la decisi√≥n tomada para trazabilidad futura.
  
!         Args:
!             decision (dict): Decisi√≥n seleccionada.
!         """
!         try:
!             versioned = version_rule(decision)
!             logger.info(f"[üîê] Decisi√≥n versionada: {versioned.get('checksum')}")
              # Aqu√≠ se puede conectar con sistema de logging extendido, blockchain interno o GPG.
!         except Exception as e:
!             logger.warning(f"[‚ö†Ô∏è] No se pudo versionar la decisi√≥n: {e}", exc_info=True)
  
!     def assert_fact(self, key: str, value: Any) -> None:
!         """
!         Inyecta un hecho simb√≥lico al motor de reglas.
  
!         Args:
!             key (str): Nombre del hecho simb√≥lico.
!             value (Any): Valor asociado.
  
!         Raises:
!             AttributeError: Si el motor simb√≥lico no soporta esta operaci√≥n.
!         """
!         if hasattr(self.engine, "assert_fact") and callable(getattr(self.engine, "assert_fact")):
!             logger.debug(f"[‚ûï] Afirmando hecho simb√≥lico: {key} = {value}")
!             try:
!                 self.engine.assert_fact(key, value)
!                 logger.info(f"[‚úÖ] Hecho simb√≥lico afirmado: {key} = {value}")
!             except Exception as e:
!                 logger.error(f"[‚ùå] Fallo al afirmar hecho simb√≥lico '{key}': {e}", exc_info=True)
!         else:
!             raise AttributeError("[SymbolicDecisionEngine] El motor simb√≥lico no implementa 'assert_fact'.")
