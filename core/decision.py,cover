  # core/decision.py
  # -*- coding: utf-8 -*-
> """
> MÃ³dulo central de decisiones de EvoAnimusAI.
> ClasificaciÃ³n: Militar / Gubernamental / Ultra-secreto
  
> Encapsula el flujo de decisiÃ³n simbÃ³lica, retroalimentaciÃ³n por refuerzo y mutaciÃ³n evolutiva.
> Auditable, validado y altamente trazable.
> """
  
! import logging
! from typing import Optional, Any
  
! from symbolic_ai.symbolic_decision_engine import SymbolicDecisionEngine  # ğŸ” IntegraciÃ³n oficial
  
! logger = logging.getLogger("EvoAI.DecisionEngine")
  
  
! class DecisionEngine:
!     """
!     Motor de decisiones central. Orquesta el uso del motor simbÃ³lico para decidir,
!     actualizar, mutar y guardar reglas simbÃ³licas.
  
!     Attributes:
!         engine (SymbolicDecisionEngine): Motor simbÃ³lico acoplado dinÃ¡micamente.
!     """
  
!     engine: SymbolicDecisionEngine
  
!     def __init__(self, context: Optional[Any] = None, symbolic_context: Optional[SymbolicDecisionEngine] = None) -> None:
!         """
!         Inicializa el DecisionEngine con un motor simbÃ³lico validado.
  
!         Args:
!             context (Optional[Any]): Contexto para inicializar SymbolicDecisionEngine si no se provee motor.
!             symbolic_context (Optional[SymbolicDecisionEngine]): Motor simbÃ³lico inyectado.
!         Raises:
!             TypeError: Si el motor simbÃ³lico no cumple la interfaz requerida.
!             ValueError: Si no se proporciona contexto o motor simbÃ³lico vÃ¡lido.
!         """
!         required_methods = ['decide', 'get_rule_by_action', 'update_rule', 'mutate_rules', 'save_rules']
  
!         if symbolic_context is not None:
!             if not all(callable(getattr(symbolic_context, m, None)) for m in required_methods):
!                 raise TypeError("[DecisionEngine] El motor simbÃ³lico no cumple con la interfaz requerida.")
!             self.engine = symbolic_context
!         else:
!             if context is None:
!                 raise ValueError("[DecisionEngine] Se requiere un contexto vÃ¡lido para inicializar SymbolicDecisionEngine.")
!             self.engine = SymbolicDecisionEngine(context)
  
!         logger.info("[âœ… DecisionEngine] Inicializado con SymbolicDecisionEngine validado.")
  
!     @property
!     def symbolic_engine(self) -> SymbolicDecisionEngine:
!         """
!         Propiedad para acceder al motor simbÃ³lico internamente.
  
!         Returns:
!             SymbolicDecisionEngine: Motor simbÃ³lico acoplado.
!         """
!         return self.engine
  
!     def decide(self) -> Any:
!         """
!         Ejecuta el proceso de decisiÃ³n usando el motor simbÃ³lico integrado.
  
!         Returns:
!             dict: AcciÃ³n decidida con metadatos.
!         Raises:
!             RuntimeError: Si falla la ejecuciÃ³n del motor simbÃ³lico.
!         """
!         logger.debug("[ğŸ§  DecisionEngine] Ejecutando decisiÃ³n...")
!         try:
!             action = self.engine.decide()
!             logger.info(f"[ğŸ§  DecisionEngine] AcciÃ³n decidida: {action}")
!             return action
!         except Exception as e:
!             logger.error(f"[âŒ DecisionEngine] Error al decidir: {e}")
!             raise RuntimeError(f"Fallo crÃ­tico en decisiÃ³n: {e}")
  
!     def update(self, action: Any, reward: float) -> None:
!         """
!         Actualiza el sistema con una action y recompensa recibida.
  
!         Args:
!             action (Any): AcciÃ³n tomada.
!             reward (float): Recompensa obtenida.
!         Raises:
!             ValueError: Si la recompensa no es numÃ©rica.
!             RuntimeError: Si falla la actualizaciÃ³n en el motor simbÃ³lico.
!         """
!         if not isinstance(reward, (int, float)):
!             raise ValueError("[DecisionEngine] Recompensa debe ser numÃ©rica.")
  
!         logger.debug(f"[ğŸ§  DecisionEngine] Actualizando con action={action} y reward={reward}")
!         try:
!             rule = self.engine.get_rule_by_action(action)
!             if rule:
!                 self.engine.update_rule(rule, reward)
!                 logger.info(f"[ğŸ§  DecisionEngine] Regla actualizada con recompensa {reward}")
!             else:
!                 logger.warning("[âš ï¸ DecisionEngine] No se encontrÃ³ regla para la action proporcionada.")
!         except Exception as e:
!             logger.error(f"[âŒ DecisionEngine] Error en update: {e}")
!             raise RuntimeError(f"Error en actualizaciÃ³n de decisiÃ³n: {e}")
  
!     def mutate(self) -> None:
!         """
!         Ejecuta una mutaciÃ³n de reglas simbÃ³licas dentro del motor.
  
!         Raises:
!             RuntimeError: Si falla la mutaciÃ³n.
!         """
!         logger.debug("[ğŸ§¬ DecisionEngine] Ejecutando mutaciÃ³n simbÃ³lica.")
!         try:
!             self.engine.mutate_rules()
!             logger.info("[ğŸ§¬ DecisionEngine] MutaciÃ³n completada con Ã©xito.")
!         except Exception as e:
!             logger.error(f"[âŒ DecisionEngine] Error durante mutaciÃ³n: {e}")
!             raise RuntimeError(f"Fallo en mutaciÃ³n de reglas: {e}")
  
!     def save(self) -> None:
!         """
!         Persiste el state simbÃ³lico del sistema.
  
!         Raises:
!             RuntimeError: Si ocurre un error al guardar.
!         """
!         logger.debug("[ğŸ’¾ DecisionEngine] Guardando reglas simbÃ³licas.")
!         try:
!             self.engine.save_rules()
!             logger.info("[ğŸ’¾ DecisionEngine] Reglas persistidas correctamente.")
!         except Exception as e:
!             logger.error(f"[âŒ DecisionEngine] Error al guardar reglas: {e}")
!             raise RuntimeError(f"Error al persistir reglas simbÃ³licas: {e}")
